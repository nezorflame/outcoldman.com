---
categories: ru
date: "2012-07-03T06:38:00Z"
aliases:
- /ru/blog/show/317/
- /ru/archive/2012/07/03/проблемы-предыдущей-задачи/
tags:
- C#
- Example
- Простые задачи
title: Проблемы предыдущей задачи
slug: "проблемы-предыдущеи-задачи"
---
<p>Итак, пару дней назад я опубликовал очень простую задачу, смысл который заключался в том, чтобы определить проблему вот этого кода:
</p><p><img src="/library/2012/07/03/070312_0638_1.png" alt=""/>
	</p><p>Как я и ожидал – правильные ответы нашлись. Не знаю, что толкает людей делать статические поля, а еще хуже - инициализацию в статических методах. Неужели мало примеров о том, что это плохо? В общем, очевидных проблем нашлось тут много: поток никто не закрывает (на самом деле это был мой запланированный отвлекающий маневр, хотя смысла в нем, наверное, нет). Кто-то просто сказал, что хорошо было бы проверки вставить, чтобы не получить NullReferenceException – полностью согласен.
</p><p>Но самая большая проблема этого кода (да и вообще всех статических конструкторов и инициализаций статических переменных), что никто не будет ожидать, что метод IsObsolete может бросить NullReferenceException. И правильно сказали в комментариях, если код их метода GetLegacyStatements выдаст исключение, то класс не будет проиницилизирован должным образом, и переменная ApplicationObsoleteStatements будет равен null. Как такого можно достичь? Кто-нибудь что-нибудь поменяет, этот метод не будет убивать AppDomain, да и использоваться этот код будет редко – вот и будет результат.</p>
